const RitaScriptVisitor = require('../lib/RitaScriptVisitor').RitaScriptVisitor;
const Entities = require('he');

String.prototype.uc = function () {
  return this.toUpperCase();
}

String.prototype.ucf = function () {
  return this[0].toUpperCase() + this.substring(1);
}

class Symbol {
  constructor(visitor, text) {
    this.text = text;
    this.parent = visitor;
    this.transforms = null;
  }
  getText() { return this.text; }
  accept() {
    this.text = this.parent.context[this.text] || this.text;
    return this.parent.visitTerminal(this);
  }
}

/**
 * This Visitor walks the tree generated by a parser
 */
class Visitor extends RitaScriptVisitor {

  constructor(context, lexerRules, parserRules, trace) {
    super();
    this.trace = trace || false;
    this.lexerRules = lexerRules;
    this.parserRules = parserRules;
    this.context = context || {};
  }

  // Visits a leaf node and returns a string
  visitTerminal(ctx) {
    let term = ctx.getText();
    if (term === Visitor.EOF) return '';

    if (ctx.transforms && (typeof term !== 'string' || term.length)) {
      for (let i = 0; i < ctx.transforms.length; i++) {
        let transform = ctx.transforms[i];
        let comps = transform.split('.');
        for (let j = 1; j < comps.length; j++) {
          //console.log(j,comps[j]);
          if (comps[j].endsWith(Visitor.FUNCTION)) { // remove parens
            comps[j] = comps[j].substring(0, comps[j].length - 2);
          }
          if (typeof term[comps[j]] === 'function') {
            term = term[comps[j]]();
          } else if (term.hasOwnProperty(comps[j])) {
            term = term[comps[j]];
          } else {
            //console.warn('Bad transform:', transform, 'for', JSON.stringify(term));
            term = ctx.getText() + ctx.transforms[i];
          }
        }
      }
    }
    let result = (typeof term === 'string') ?
      Entities.decode(term) : JSON.stringify(term);

    this.trace && console.log('visitTerminal: "', result, '"');

    return result;
  }

  visitAssign(ctx) {
    let id = this.symbolName(ctx.symbol().getText());
    let token = ctx.expr();

    token.transforms = this.inheritTransforms(token, ctx);
    this.trace && console.log('visitAssign: $' + id + '=' +
      this.flatten(token), "tfs=" + (token.transforms || "[]"));
    this.context[id] = this.visit(token);

    let delims = ctx.children[0].getText() + ctx.children[4].getText();
    if (delims === Visitor.ASSIGN) {
      return this.context[id];
    }
    if (delims === Visitor.SASSIGN) {
      if (token.transforms && token.transforms.length) {
        throw Error('Transforms not allowed on silent assignments: ' + ctx.getText());
      }
      return ''; // silent
    }
    throw Error('Bad assign delims: ' + delims);
  }

  visitSymbol(ctx) {
    let id = this.symbolName(ctx.ident().getText());
    let symbol = new Symbol(this, id);
    symbol.transforms = this.inheritTransforms(symbol, ctx);
    this.trace && console.log('visitSymbol: $' + symbol.text + ' ' + (symbol.transforms || "[]"));
    return this.visit(symbol);
  }

  visitChoice(ctx) {
    let options = ctx.expr();
    this.handleEmptyChoices(ctx, options);
    let token = this.randomElement(options);
    if (typeof token === 'string') {
      this.trace && console.log('visitChoice: "' + token + '"');
      return token; // fails for transforms ?
    } else {
      token.transforms = this.inheritTransforms(token, ctx);
      this.trace && console.log('visitChoice: ' + this.flattenChoice(token), "tfs=" + (token.transforms || "[]"));
      return this.visit(token);
    }
  }

  // ---------------------- Helpers ---------------------------

  symbolName(text) {
    return (text.length && text[0] === Visitor.SYM) ? text.substring(1) : text;
  }

  getRuleName(ctx) {
    return ctx.hasOwnProperty('symbol') ?
      this.lexerRules[ctx.symbol.type] :
      this.parserRules[ctx.ruleIndex];
  }

  countChildRules(ctx, ruleName) {
    let count = 0;
    for (let i = 0; i < ctx.getChildCount(); i++) {
      if (this.getRuleName(ctx.getChild(i)) === ruleName) count++;
    }
    return count;
  }

  printChildren(ctx) {
    for (let i = 0; i < ctx.getChildCount(); i++) {
      let child = ctx.getChild(i);
      console.log(i, child.getText(), this.getRuleName(child));
    }
  }

  flatten(toks) {
    if (!Array.isArray(toks)) toks = [toks];
    return toks.reduce((acc, t) => acc += '[' + this.getRuleName(t) + ':' + t.getText() + ']', '');
  }

  flattenChoice(toks) {
    if (!Array.isArray(toks)) toks = [toks];
    return toks.reduce((acc, t) => acc += '[' + this.getRuleName(t) + ':' + t.getText() + ']', 'choice: ');
  }

  appendToArray(orig, adds) {
    return (adds && adds.length) ? (orig || []).concat(adds) : orig;
  }

  inheritTransforms(token, ctx) {
    let newTransforms = ctx.transform().map(t => t.getText()); //.substring(1, t.getText().length - 2));
    newTransforms = this.appendToArray(newTransforms, ctx.transforms);
    return this.appendToArray(token.transforms, newTransforms);
  }

  handleEmptyChoices(ctx, options) {
    let ors = this.countChildRules(ctx, Visitor.OR);
    let exprs = this.countChildRules(ctx, "expr");
    let adds = (ors + 1) - exprs;
    for (let i = 0; i < adds; i++) options.push(""); // should be token
  }

  randomElement(arr) {
    return arr[Math.floor((Math.random() * arr.length))];
  }

  visitChildren(ctx) {
    return ctx.children.reduce((acc, child) => {
      (child.transforms = ctx.transforms);
      return acc + this.visit(child);
    }, '');
  }

  // Entry point for tree visiting
  start(ctx) {
    return this.visitScript(ctx).trim().replace(/ +/g, ' ');
  }
}

Visitor.LP = '(';
Visitor.RP = ')';
Visitor.OR = 'OR';
Visitor.SYM = '$';
Visitor.EOF = '<EOF>';
Visitor.ASSIGN = '[]';
Visitor.SASSIGN = '{}';
Visitor.FUNCTION = '()';

module.exports = Visitor;
